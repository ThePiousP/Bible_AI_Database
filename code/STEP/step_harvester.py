
"""
step_harvester.py — STEP Bible DOM harvester

Purpose
-------
Scrape an already-openable STEP Bible offline app/page (served from file:// or http://localhost)
and extract per‑word alignment (surface form, Strong's, lemma, morph, language) grouped by verse.
Outputs JSON by chapter and/or inserts into a SQLite table for downstream NER alignment.

Design notes
------------
• 1‑based indexing for token positions, as requested.
• Keeps your existing books.book_name strings; no remapping required. Just pass the book name you already use.
• Selectors & attributes are configurable so you can adapt to whatever markup the STEP build exposes.
• No changes to your existing config.json are made by default. A separate step_config.json is used.

Quick start
-----------
1) pip install playwright
   playwright install

2) Create/Edit step_config.json next to this file (see template generated by this notebook).
   Put the absolute app_url to your local STEP index page. Adjust selectors/attrs if needed.

3) Run (chapter → JSON):
   python step_harvester.py --mode chapter --book "Genesis" --chapter 22

   Or harvest a whole book:
   python step_harvester.py --mode book --book "Genesis"

   Or insert directly into GoodBook.db (creates table if missing):
   python step_harvester.py --mode book --book "Genesis" --sqlite GoodBook.db

Schema (optional SQLite)
------------------------
Table: word_index
  book_name TEXT NOT NULL
  chapter_number INTEGER NOT NULL
  verse_number INTEGER NOT NULL
  token_index INTEGER NOT NULL     -- 1-based within verse
  surface TEXT NOT NULL
  strongs TEXT                      -- space- or comma-separated if multiple
  lemma TEXT
  morph TEXT
  lang TEXT

Composite key (book_name, chapter_number, verse_number, token_index)
"""

import os
import re
import json
import time
import argparse
import sqlite3
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional, Tuple

# Playwright (sync) keeps runtime simple
from playwright.sync_api import sync_playwright, TimeoutError as PWTimeout

# ---------- Data model ----------

@dataclass
class WordRec:
    book_name: str
    chapter_number: int
    verse_number: int
    token_index: int   # 1-based within verse
    surface: str
    strongs: str = ""
    lemma: str = ""
    morph: str = ""
    lang: str = ""


# ---------- Utilities ----------

def load_step_config(path: str = "step_config.json") -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    # Simple validation
    required = ["app_url", "url_template", "selectors"]
    for k in required:
        if k not in cfg:
            raise ValueError(f"Missing '{k}' in {path}")
    return cfg

def ensure_dir(path: str):
    os.makedirs(path, exist_ok=True)

def create_alignment_table(db_path: str):
    sql = """
    CREATE TABLE IF NOT EXISTS word_index (
      book_name TEXT NOT NULL,
      chapter_number INTEGER NOT NULL,
      verse_number INTEGER NOT NULL,
      token_index INTEGER NOT NULL,
      surface TEXT NOT NULL,
      strongs TEXT,
      lemma TEXT,
      morph TEXT,
      lang TEXT,
      PRIMARY KEY (book_name, chapter_number, verse_number, token_index)
    );
    """
    with sqlite3.connect(db_path) as conn:
        conn.execute(sql)

def insert_records(db_path: str, rows: List[WordRec]):
    if not rows:
        return
    create_alignment_table(db_path)
    with sqlite3.connect(db_path) as conn:
        conn.executemany(
            """INSERT OR REPLACE INTO word_index
               (book_name, chapter_number, verse_number, token_index, surface, strongs, lemma, morph, lang)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",
            [(r.book_name, r.chapter_number, r.verse_number, r.token_index, r.surface, r.strengths if hasattr(r,'strengths') else r.strongs, r.lemma, r.morph, r.lang) for r in rows]
        )

def write_chapter_json(out_root: str, book: str, chap: int, rows: List[WordRec]):
    out_dir = os.path.join(out_root, book)
    ensure_dir(out_dir)
    out_path = os.path.join(out_dir, f"{chap}.json")
    payload = {
        "book_name": book,
        "chapter_number": chap,
        "verses": {}
    }
    for r in rows:
        payload["verses"].setdefault(str(r.verse_number), [])
        payload["verses"][str(r.verse_number)].append(asdict(r))
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2, ensure_ascii=False)
    return out_path

# ---------- Core harvester ----------

class StepHarvester:
    def __init__(self, config: Dict[str, Any], headless: bool = True):
        self.cfg = config
        self.headless = headless

        self.app_url = self.cfg["app_url"]
        self.url_template = self.cfg["url_template"]
        self.sel = self.cfg["selectors"]
        # Defaults for optional attrs
        self.attr_strongs = self.sel.get("word_strongs_attr", "data-strong")  # STEP builds vary; adjust as needed
        self.attr_lemma   = self.sel.get("word_lemma_attr", "data-lemma")
        self.attr_morph   = self.sel.get("word_morph_attr", "data-morph")
        self.attr_lang    = self.sel.get("word_lang_attr", "lang")

        # Additional behavior knobs
        self.wait_after_nav_ms = int(self.cfg.get("wait_after_nav_ms", 350))  # allow DOM hydration
        self.nav_timeout_ms    = int(self.cfg.get("nav_timeout_ms", 15000))
        self.query_timeout_ms  = int(self.cfg.get("query_timeout_ms", 15000))

    def _format_url(self, book: str, chap: int) -> str:
        # Allow placeholders {app_url}, {book}, {chapter}
        return self.url_template.format(app_url=self.app_url, book=book, chapter=chap)

    def harvest_chapter(self, book: str, chap: int) -> List[WordRec]:
        out: List[WordRec] = []
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=self.headless)
            ctx = browser.new_context()
            page = ctx.new_page()

            url = self._format_url(book, chap)
            try:
                page.goto(url, timeout=self.nav_timeout_ms)
            except PWTimeout:
                browser.close()
                raise RuntimeError(f"Navigation timeout: {url}")

            # Wait for the "chapter is ready" anchor: either a verse container or token exists
            anchor_sel = self.sel.get("ready_selector") or self.sel["verse"] or self.sel["word"]
            try:
                page.wait_for_selector(anchor_sel, timeout=self.query_timeout_ms)
            except PWTimeout:
                browser.close()
                raise RuntimeError(f"Selector not found after load: {anchor_sel}")

            # small extra delay for hydration
            time.sleep(self.wait_after_nav_ms / 1000.0)

            # Evaluate in-page to gather data (faster & robust than many round trips)
            verse_sel = self.sel["verse"]
            word_sel  = self.sel["word"]
            verse_ref_attr = self.sel.get("verse_ref_attr", "data-verse")  # try to read explicit verse no if provided

            js = f"""
            () => {{
              const verseNodes = Array.from(document.querySelectorAll({json.dumps(verse_sel)}));
              const results = [];

              function getVerseNumber(vnode) {{
                // Try explicit attr, else scan for a child with a number, else last resort regex
                const refAttr = {json.dumps(verse_ref_attr)};
                let vnum = vnode.getAttribute(refAttr);
                if (vnum) return vnum;

                // common patterns like <span class="v-num">3</span>
                const numEl = vnode.querySelector('.v-num, .verse-num, [data-verse], [data-v]');
                if (numEl) {{
                  const n = (numEl.getAttribute('data-verse') || numEl.getAttribute('data-v') || numEl.textContent || '').trim();
                  if (n) return n;
                }}

                // fallback: look for something that looks like a number in text
                const m = (vnode.textContent || '').match(/\\b(\\d+)\\b/);
                return m ? m[1] : '';
              }}

              function normStrong(raw) {{
                if (!raw) return '';
                // normalize delimiters: STEP can join multiple with space, slash, or comma
                return raw.replace(/[_\\s\\/]+/g, ' ').trim();
              }}

              verseNodes.forEach(vnode => {{
                const vnum = getVerseNumber(vnode) || '';
                const words = Array.from(vnode.querySelectorAll({json.dumps(word_sel)}));
                let t = 0;
                words.forEach(w => {{
                  // skip punctuation-only nodes
                  const surface = (w.textContent || '').replace(/\\s+/g, ' ').trim();
                  if (!surface || /^[\\p{{P}}]+$/u.test(surface)) return;

                  const rec = {{
                    verse: vnum,
                    token_index: ++t,
                    surface: surface,
                    strongs: normStrong(w.getAttribute({json.dumps(self.attr_strongs)})),
                    lemma: (w.getAttribute({json.dumps(self.attr_lemma)}) || ''),
                    morph: (w.getAttribute({json.dumps(self.attr_morph)}) || ''),
                    lang:  (w.getAttribute({json.dumps(self.attr_lang)}) || '')
                  }};
                  results.push(rec);
                }});
              }});
              return results;
            }}
            """
            data = page.evaluate(js)

            browser.close()

        # Post-process: coerce verse numbers, build WordRec objects
        for row in data:
            # Verse could be empty if selector couldn't find; try to infer by reset on token_index 1
            verse_no = int(row["verse"]) if str(row.get("verse","")).isdigit() else None
            if verse_no is None:
                # heuristic: cannot recover reliably here; leave as 0 to surface the issue
                verse_no = 0

            out.append(WordRec(
                book_name=book,
                chapter_number=int(chap),
                verse_number=verse_no,
                token_index=int(row["token_index"]),
                surface=row["surface"],
                strongs=row.get("strongs",""),
                lemma=row.get("lemma",""),
                morph=row.get("morph",""),
                lang=row.get("lang",""),
            ))
        return out

    def harvest_book(self, book: str, chapter_count: Optional[int] = None) -> Dict[int, List[WordRec]]:
        """
        If chapter_count is not supplied, tries numbers 1..150 and stops when a chapter fails to render twice.
        Prefer passing explicit chapter_count from your DB.
        """
        results: Dict[int, List[WordRec]] = {}
        failures = 0
        chap = 1
        hard_cap = 200  # safety

        while True:
            if chapter_count and chap > chapter_count:
                break
            if chap > hard_cap:
                break

            try:
                rows = self.harvest_chapter(book, chap)
                if rows:
                    results[chap] = rows
                    failures = 0
                else:
                    failures += 1
            except Exception as e:
                failures += 1

            if chapter_count is None and failures >= 2:
                break
            chap += 1

        return results


# ---------- CLI ----------

def main():
    ap = argparse.ArgumentParser(description="STEP Bible DOM harvester (Option A, 1-based token indices)")
    ap.add_argument("--config", default="step_config.json", help="Path to step_config.json")
    ap.add_argument("--mode", choices=["chapter", "book"], required=True)
    ap.add_argument("--book", required=True, help="Standard English book name (matches your DB)")
    ap.add_argument("--chapter", type=int, help="Chapter number (1-based)")
    ap.add_argument("--chapter-count", type=int, help="Total chapters in the book (for --mode book)")
    ap.add_argument("--outdir", default="output/step_alignment", help="Root folder for JSON output")
    ap.add_argument("--sqlite", help="Optional path to SQLite DB (e.g., GoodBook.db) for word_index inserts")
    ap.add_argument("--headless", action="store_true", help="Run headless (default)")
    ap.add_argument("--headed", dest="headless", action="store_false", help="Run with visible browser")
    ap.set_defaults(headless=True)
    args = ap.parse_args()

    cfg = load_step_config(args.config)
    harvester = StepHarvester(cfg, headless=args.headless)

    if args.mode == "chapter":
        if not args.chapter:
            ap.error("--chapter is required for --mode chapter")
        rows = harvester.harvest_chapter(args.book, args.chapter)
        ensure_dir(args.outdir)
        path = write_chapter_json(args.outdir, args.book, args.chapter, rows)
        print(f"✓ Wrote {len(rows)} tokens → {path}")
        if args.sqlite:
            insert_records(args.sqlite, rows)
            print(f"✓ Inserted {len(rows)} rows into {args.sqlite} (word_index)")

    elif args.mode == "book":
        results = harvester.harvest_book(args.book, chapter_count=args.chapter_count)
        ensure_dir(args.outdir)
        total = 0
        for chap, rows in results.items():
            path = write_chapter_json(args.outdir, args.book, chap, rows)
            total += len(rows)
            print(f"✓ [{args.book} {chap}] {len(rows)} tokens → {path}")
            if args.sqlite:
                insert_records(args.sqlite, rows)
        print(f"✓ Completed book: {args.book} | tokens={total} | chapters={len(results)}")

if __name__ == "__main__":
    main()
